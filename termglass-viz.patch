diff --git a/TermGlass/Renderer.cs b/TermGlass/Renderer.cs
index 0000000..0000000 100644
--- a/TermGlass/Renderer.cs
+++ b/TermGlass/Renderer.cs
@@ -1,200 +1,240 @@
 ... (context omitted for brevity) ...
-        else
-        {
-            var step = Math.Max(1.0, worldPerPixel * 0.8);
-            var x0 = (int)Math.Floor(wx - step * 0.5);
-            var y0 = (int)Math.Floor(wy - step * 0.5);
-
-            var acc = new (int r, int g, int b, char ch, int n)[4];
-            var count = 0;
-
-            for (var dy = 0; dy < 2; dy++)
-                for (var dx = 0; dx < 2; dx++)
-                {
-                    var c = world.GetCell(x0 + dx, y0 + dy);
-                    if (c.HasValue)
-                    {
-                        acc[count].r = c.Value.Fg.R;
-                        acc[count].g = c.Value.Fg.G;
-                        acc[count].b = c.Value.Fg.B;
-                        acc[count].ch = c.Value.Ch;
-                        acc[count].n = 1;
-                    }
-                    else acc[count].ch = ' ';
-                    count++;
-                }
-
-            // znak: najczęstszy (mode)
-            var mode = ModeChar(new[] { acc[0].ch, acc[1].ch, acc[2].ch, acc[3].ch });
-            var (R, G, B) = (acc[0].r + acc[1].r + acc[2].r + acc[3].r,
-                             acc[0].g + acc[1].g + acc[2].g + acc[3].g,
-                             acc[0].b + acc[1].b + acc[2].b + acc[3].b);
-            var fg = new Rgb((byte)(R / 4), (byte)(G / 4), (byte)(B / 4));
-            return new Cell(mode, fg, Rgb.Black);
-        }
+        else
+        {
+            var step = Math.Max(1.0, worldPerPixel * 0.8);
+            var x0 = (int)Math.Floor(wx - step * 0.5);
+            var y0 = (int)Math.Floor(wy - step * 0.5);
+
+            int fr = 0, fg = 0, fb = 0, br = 0, bg = 0, bb = 0, n = 0;
+            var chars = new char[4];
+            var count = 0;
+
+            for (var dy = 0; dy < 2; dy++)
+            for (var dx = 0; dx < 2; dx++)
+            {
+                var c = world.GetCell(x0 + dx, y0 + dy);
+                if (c.HasValue)
+                {
+                    var v = c.Value;
+                    fr += v.Fg.R; fg += v.Fg.G; fb += v.Fg.B;
+                    br += v.Bg.R; bg += v.Bg.G; bb += v.Bg.B;
+                    chars[count++] = v.Ch;
+                    n++;
+                }
+                else
+                {
+                    chars[count++] = ' ';
+                }
+            }
+
+            if (n == 0) return new Cell(' ', Rgb.White, Rgb.Black);
+
+            var ch = ModeChar(chars);
+            var avgFg = new Rgb((byte)(fr / n), (byte)(fg / n), (byte)(fb / n));
+            var avgBg = new Rgb((byte)(br / n), (byte)(bg / n), (byte)(bb / n));
+            return new Cell(ch, avgFg, avgBg);
+        }
     }
 
     public static void DrawTooltipBox(CellBuffer buf, int x0, int y0, IReadOnlyList<string> lines, byte bgAlpha = 180, byte borderAlpha = 220)
     {
         int W = buf.Width, H = buf.Height;
         if (lines == null || lines.Count == 0) return;
 
         const int padX = 1;
         var maxLineLen = 0;
         for (var i = 0; i < lines.Count; i++)
             if (lines[i] != null)
                 maxLineLen = Math.Max(maxLineLen, lines[i].Length);
 
         var w = Math.Clamp(maxLineLen + padX * 2, 6, W);
 
         if (x0 + w >= W) x0 = Math.Max(0, W - w - 1);
         var h = Math.Min(lines.Count, Math.Max(1, H - 1 - y0));
         if (h < lines.Count) h = lines.Count;
         if (y0 + h >= H - 1) y0 = Math.Max(0, H - 1 - h);
 
         var bg = new Rgb(20, 20, 20);
         var bd = new Rgb(255, 255, 255);
         var fg = new Rgb(245, 245, 245);
 
         var opaque = bgAlpha == 255 && borderAlpha == 255;
         var opaqueMode = opaque || !buf.AlphaBlendEnabled;
 
-        for (var row = 0; row < lines.Count; row++)
+        // top border
+        if (opaqueMode)
+        {
+            for (var x = 0; x < w; x++) buf.TrySet(x0 + x, y0, new Cell(' ', fg, bd));
+        }
+        else
+        {
+            for (var x = 0; x < w; x++) buf.BlendBg(x0 + x, y0, bd, borderAlpha);
+        }
+
+        for (var row = 1; row <= lines.Count; row++)
         {
-            var y = y0 + row;
+            var y = y0 + row;
             if ((uint)y >= (uint)H) break;
 
             for (var x = 0; x < w; x++)
             {
                 if (opaqueMode)
                 {
-                    // pełne nadpisanie — czyścimy znak, ustawiamy tło
-                    buf.TrySet(x0 + x, y, new Cell(' ', fg, bg));
+                    buf.TrySet(x0 + x, y, new Cell(' ', fg, bg));
                 }
                 else
                 {
-                    // półprzezroczysty blend tła
-                    buf.BlendBgAndFg(x0 + x, y, bg, bgAlpha, bg, bgAlpha);
+                    buf.BlendBgAndFg(x0 + x, y, bg, bgAlpha, bg, bgAlpha);
                 }
             }
 
-            // ramka (tylko blend lub pełne nadpisanie, w zależności od trybu)
             if (opaqueMode)
             {
                 buf.TrySet(x0, y, new Cell(' ', fg, bd));
                 buf.TrySet(x0 + w - 1, y, new Cell(' ', fg, bd));
             }
             else
             {
                 buf.BlendBg(x0, y, bd, borderAlpha);
                 buf.BlendBg(x0 + w - 1, y, bd, borderAlpha);
             }
 
-            // tekst (bez ruszania tła w trybie blend)
-            var line = lines[row] ?? string.Empty;
+            var line = lines[row - 1] ?? string.Empty;
             var inner = Math.Max(0, w - padX * 2);
             if (inner > 0 && line.Length > inner) line = line.AsSpan(0, inner).ToString();
 
             if (opaqueMode)
-                PutText(buf, x0 + padX, y, line, fg, bg); // nadpisanie z tłem
+                PutText(buf, x0 + padX, y, line, fg, bg);
             else
                 PutTextKeepBg(buf, x0 + padX, y, line, fg);
         }
+
+        // bottom border (clamp within screen, above status bar)
+        var by = Math.Min(y0 + lines.Count, H - 2);
+        if (opaqueMode)
+        {
+            for (var x = 0; x < w; x++) buf.TrySet(x0 + x, by, new Cell(' ', fg, bd));
+        }
+        else
+        {
+            for (var x = 0; x < w; x++) buf.BlendBg(x0 + x, by, bd, borderAlpha);
+        }
     }
 
 ... (rest of file unchanged) ...
diff --git a/TermGlass/Frame.cs b/TermGlass/Frame.cs
index 0000000..0000000 100644
--- a/TermGlass/Frame.cs
+++ b/TermGlass/Frame.cs
@@ -1,80 +1,88 @@
 namespace TermGlass.Core;
 
 // Drawing in world vs. screen coordinates
 public sealed class Frame
 {
     private readonly Terminal _t;
     private readonly Viewport _vp;
     private readonly CellBuffer _buf;
 
     public readonly InputState Input;
     public readonly VizConfig Cfg;
 
+    // Optional: host/AoC can set these each frame (picked up by MainLoop)
+    public string? StatusText { get; set; }
+    public TooltipProvider? TooltipProvider { get; set; }
+
     public Frame(Terminal t, Viewport vp, CellBuffer buf, InputState input, VizConfig cfg)
     {
         _t = t; _vp = vp; _buf = buf; Input = input; Cfg = cfg;
     }
 
     ... (rest of file unchanged) ...
 }
diff --git a/TermGlass/MainLoop.cs b/TermGlass/MainLoop.cs
index 0000000..0000000 100644
--- a/TermGlass/MainLoop.cs
+++ b/TermGlass/MainLoop.cs
@@ -1,120 +1,140 @@
 internal sealed class MainLoop
 {
     private const int MaxKeyEventsPerFrame = 64;
 
     private readonly Terminal _t;
     private readonly VizConfig _cfg;
     private readonly Action<Frame> _draw;
     private readonly Viewport _vp;
     private readonly CellBuffer _buf;
     private readonly InputState _input = new();
     private readonly Stopwatch _sw = new();
     private double _accum = 0;
     private InputReader? _inputReader;
     private readonly TooltipProvider? _tooltip;
     private bool _tooltipEnabled = true;
+    private string? _statusFromFrame;
+    private TooltipProvider? _tooltipFromFrame;
 
     private int _frameCounter = 0;
     private double _fps = 0.0;
     private DateTime _fpsLastTime = DateTime.UtcNow;
 
     private Window? _helpWin;
 
     public MainLoop(Terminal t, VizConfig cfg, Action<Frame> draw, TooltipProvider? tooltip = null)
     {
         _t = t; _cfg = cfg; _draw = draw;
         _tooltip = tooltip;
         _vp = new Viewport();
         _buf = new CellBuffer(_t.Width, _t.Height);
         _vp.AttachTerminal(_t);
     }
 
     public void Run()
     {
         ... (unchanged setup code) ...
 
-            if (_input.Dirty)
+            if (_input.Dirty)
             {
                 _input.Dirty = false;
 
                 _buf.AlphaBlendEnabled = _cfg.ColorMode == ColorMode.TrueColor;
 
                 _buf.Fill(new Cell(' ', Rgb.White, Rgb.Black));
 
                 var frame = new Frame(_t, _vp, _buf, _input, _cfg);
-                _draw(frame);
+                _draw(frame);
+                _statusFromFrame = frame.StatusText;
+                _tooltipFromFrame = frame.TooltipProvider;
 
                 if (_cfg.Layers.HasFlag(UiLayers.Rulers)) DrawRulers();
 
                 // windows — on top of content and rulers
                 Window.DrawAll(_buf);
 
                 // === TOOLTIP (above everything except the status bar) ===
                 DrawTooltipIfAny();
 
                 if (_cfg.Layers.HasFlag(UiLayers.StatusBar)) DrawStatusBar();
 
                 _t.Draw(_buf);
 
                 ... (unchanged fps code) ...
 
                 _input.StepRequested = false;
                 _input.ConsumedMouseMove();
             }
             else
             {
                 // nothing changed → tiny sleep
                 Thread.Sleep(1);
             }
 
             ... (unchanged throttle) ...
         }
 
         ... (unchanged teardown) ...
     }
 
     private void DrawStatusBar()
     {
         int W = _t.Width, H = _t.Height;
         if (W < 10 || H < 3) return;
 
         for (var x = 0; x < W; x++)
             _buf.Set(x, H - 1, new Cell(' ', Rgb.Black, Rgb.Gray));
 
         // world cell under cursor (with correction for zoom<1)
         var (ix, iy) = _vp.WorldCellUnderScreen(_input.MouseX, _input.MouseY);
         var autoInfo = _cfg.AutoPlay ? $"{_cfg.AutoStepPerSecond:F1}/s | FPS {_fps:F1}" : "off";
 
-        var info = $" {_cfg.ColorMode} | {_cfg.Layers} | Zoom {_vp.Zoom:F2} | Auto {autoInfo} | Cell {ix}, {iy}";
-        var status = $"F1 Help | {info}".PadRight(W);
+        var baseText = $" {_cfg.ColorMode} | {_cfg.Layers} | Zoom {_vp.Zoom:F2} | Auto {autoInfo} | Cell {ix}, {iy}";
+        var line = $"F1 Help | {baseText}";
+        if (!string.IsNullOrWhiteSpace(_statusFromFrame))
+        {
+            var room = Math.Max(0, W - line.Length - 3);
+            if (room > 0)
+            {
+                var extra = _statusFromFrame!.Length > room ? _statusFromFrame.Substring(0, room) : _statusFromFrame;
+                line = $"{line} | {extra}";
+            }
+        }
+        var status = line.PadRight(W);
 
         Renderer.PutText(_buf, 0, H - 1, status[..Math.Min(W, status.Length)], Rgb.Black, Rgb.Gray);
     }
 
     private void DrawTooltipIfAny()
     {
-        if (!_tooltipEnabled) return; // <-- new line
-        if (_tooltip == null) return;
+        if (!_tooltipEnabled) return;
+        var provider = _tooltipFromFrame ?? _tooltip;
+        if (provider == null) return;
         if (!_cfg.Layers.HasFlag(UiLayers.Overlays)) return;
 
         var (wx, wy) = _vp.ScreenToWorld(_input.MouseX, _input.MouseY);
         // Skip tooltip if cursor is over a window
         var overWindow = Window.All().Any(w =>
             w.Visible &&
             _input.MouseX >= w.X &&
             _input.MouseX < w.X + w.W &&
             _input.MouseY >= w.Y &&
             _input.MouseY < w.Y + w.H);
 
         if (overWindow)
         {
             return;
         }
 
-        var (ix, iy) = _vp.WorldCellUnderScreen(_input.MouseX, _input.MouseY);
-        var text = _tooltip(ix, iy);
+        var (ix, iy) = _vp.WorldCellUnderScreen(_input.MouseX, _input.MouseY);
+        var text = provider(ix, iy);
         if (string.IsNullOrEmpty(text)) return;
 
         ... (rest of method unchanged) ...
     }
 }
